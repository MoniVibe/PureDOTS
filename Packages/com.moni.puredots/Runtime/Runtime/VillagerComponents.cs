using System;
using PureDOTS.Runtime.Registry;
using Unity.Collections;
using Unity.Entities;
using Unity.Mathematics;

namespace PureDOTS.Runtime.Components
{
    /// <summary>
    /// Core villager identification and type.
    /// </summary>
    public struct VillagerId : IComponentData
    {
        public int Value;
        public int FactionId;
    }

    /// <summary>
    /// Villager needs that must be satisfied.
    /// </summary>
    public struct VillagerNeeds : IComponentData
    {
        public float Health;
        public float MaxHealth;
        public float Hunger;       // 0-100, increases over time
        public float Energy;       // 0-100, decreases with work
        public float Morale;       // 0-100, affects productivity
        public float Temperature;  // Comfort level
    }

    /// <summary>
    /// Supported discipline types. Mirrors GodGame.Villagers.Discipline.
    /// </summary>
    public enum VillagerDisciplineType : byte
    {
        Unassigned = 0,
        Forester = 1,
        Breeder = 2,
        Worshipper = 3,
        Miner = 4,
        Warrior = 5,
        Farmer = 6,
        Builder = 7
    }

    /// <summary>
    /// Discipline state used for job assignment & UI.
    /// </summary>
    public struct VillagerDisciplineState : IComponentData
    {
        public VillagerDisciplineType Value;
        public byte Level;
        public float Experience;
    }

    /// <summary>
    /// High level mood / wellbeing metrics derived from needs.
    /// </summary>
    public struct VillagerMood : IComponentData
    {
        public float Mood;          // 0-100 current mood
        public float TargetMood;    // Desired mood (for lerp)
        public float MoodChangeRate; // Units per second toward target
        public float Wellbeing;     // Aggregate of needs (0-100)
    }

    /// <summary>
    /// Availability flags for scheduling / job systems.
    /// </summary>
    public struct VillagerAvailability : IComponentData
    {
        public byte IsAvailable;    // 1 = available for work
        public byte IsReserved;     // 1 = currently reserved/assigned
        public uint LastChangeTick; // For history/analytics
        public float BusyTime;      // Seconds spent busy in current stint
    }

    /// <summary>
    /// Current AI state and goal.
    /// </summary>
    public struct VillagerAIState : IComponentData
    {
        public enum State : byte
        {
            Idle = 0,
            Working = 1,
            Eating = 2,
            Sleeping = 3,
            Fleeing = 4,
            Fighting = 5,
            Dead = 6,
            Travelling = 7
        }

        public enum Goal : byte
        {
            None = 0,
            SurviveHunger = 1,
            Work = 2,
            Rest = 3,
            Flee = 4,
            Fight = 5,
            Socialize = 6,
            Reproduce = 7
        }

        public State CurrentState;
        public Goal CurrentGoal;
        public Entity TargetEntity;
        public float3 TargetPosition;
        public float StateTimer;
        public uint StateStartTick;
    }

    /// <summary>
    /// Current job assignment.
    /// </summary>
    public struct VillagerJob : IComponentData
    {
        public enum JobType : byte
        {
            None = 0,
            Farmer = 1,
            Builder = 2,
            Gatherer = 3,
            Hunter = 4,
            Guard = 5,
            Priest = 6,
            Merchant = 7,
            Crafter = 8
        }

        public enum JobPhase : byte
        {
            Idle = 0,
            Assigned = 1,
            Gathering = 2,
            Delivering = 3,
            Completed = 4,
            Interrupted = 5
        }

        public JobType Type;
        public JobPhase Phase;
        public uint ActiveTicketId;
        public float Productivity; // 0-1, affected by needs and morale
        public uint LastStateChangeTick;
    }

    /// <summary>
    /// Movement and pathfinding data.
    /// </summary>
    public struct VillagerMovement : IComponentData
    {
        public float3 Velocity;
        public float BaseSpeed;
        public float CurrentSpeed;
        public quaternion DesiredRotation;
        public byte IsMoving;
        public byte IsStuck;
        public uint LastMoveTick;
    }

    /// <summary>
    /// Inventory of carried resources.
    /// </summary>
    public struct VillagerInventoryItem : IBufferElementData
    {
        public FixedString64Bytes ResourceTypeId;
        public float Amount;
        public float MaxCarryCapacity;
    }

    /// <summary>
    /// Withdrawal requests generated by villager behaviour systems.
    /// </summary>
    public struct VillagerWithdrawRequest : IBufferElementData
    {
        public FixedString64Bytes ResourceTypeId;
        public float Amount;
        public Entity TargetStorehouse;
    }

    /// <summary>
    /// Combat stats for villager.
    /// </summary>
    public struct VillagerCombatStats : IComponentData
    {
        public float AttackDamage;
        public float AttackSpeed;
        public float DefenseRating;
        public float AttackRange;
        public Entity CurrentTarget;
        public float LastAttackTime;
    }

    /// <summary>
    /// Social relationships with other villagers.
    /// </summary>
    public struct VillagerRelationship : IBufferElementData
    {
        public Entity OtherVillager;
        public float RelationshipValue; // -100 to 100
        public byte RelationType; // Friend, Enemy, Family, etc.
    }

    /// <summary>
    /// Path waypoints for navigation.
    /// </summary>
    public struct VillagerPathWaypoint : IBufferElementData
    {
        public float3 Position;
        public byte WaypointType; // Normal, Door, Ladder, etc.
    }

    /// <summary>
    /// Sensor data for environment awareness.
    /// </summary>
    public struct VillagerSensors : IComponentData
    {
        public float VisionRange;
        public float HearingRange;
        public Entity NearestThreat;
        public Entity NearestFood;
        public Entity NearestShelter;
        public float3 LastKnownThreatPosition;
        public uint LastSensorUpdateTick;
    }

    /// <summary>
    /// Tags for special villager states.
    /// </summary>
    public struct VillagerSelectedTag : IComponentData { }
    public struct VillagerHighlightedTag : IComponentData { }
    public struct VillagerInCombatTag : IComponentData { }
    public struct VillagerCarryingTag : IComponentData { }
    public struct VillagerDeadTag : IComponentData { }

    /// <summary>
    /// Command buffer for villager AI decisions.
    /// </summary>
    public struct VillagerCommand : IBufferElementData
    {
        public enum CommandType : byte
        {
            MoveTo = 0,
            Attack = 1,
            Gather = 2,
            Build = 3,
            Deposit = 4,
            Eat = 5,
            Sleep = 6,
            Flee = 7,
            Guard = 8
        }

        public CommandType Type;
        public Entity TargetEntity;
        public float3 TargetPosition;
        public float Priority;
        public uint IssuedTick;
    }

    /// <summary>
    /// Villager spawning configuration.
    /// </summary>
    public struct VillagerSpawnConfig : IComponentData
    {
        public Entity VillagerPrefab;
        public float3 SpawnPosition;
        public int InitialPopulation;
        public float SpawnRadius;
        public int MaxPopulation;
        public float ReproductionRate;
    }

    /// <summary>
    /// Tracks villager animations and visual state.
    /// </summary>
    public struct VillagerAnimationState : IComponentData
    {
        public enum AnimationType : byte
        {
            Idle = 0,
            Walk = 1,
            Run = 2,
            Work = 3,
            Attack = 4,
            Die = 5,
            Eat = 6,
            Sleep = 7,
            Celebrate = 8
        }

        public AnimationType CurrentAnimation;
        public float AnimationSpeed;
        public float AnimationTime;
        public byte ShouldUpdateAnimation;
    }

    /// <summary>
    /// Villager statistics for gameplay tracking.
    /// </summary>
    public struct VillagerStats : IComponentData
    {
        public uint BirthTick;
        public uint DeathTick;
        public float TotalWorkDone;
        public float TotalResourcesGathered;
        public int EnemiesKilled;
        public int BuildingsConstructed;
        public float DistanceTraveled;
    }

    /// <summary>
    /// Memory of recent events for decision making.
    /// </summary>
    public struct VillagerMemoryEvent : IBufferElementData
    {
        public enum EventType : byte
        {
            SawThreat = 0,
            WasAttacked = 1,
            FoundFood = 2,
            CompletedWork = 3,
            MetFriend = 4,
            HeardSound = 5
        }

        public EventType Type;
        public float3 EventPosition;
        public Entity RelatedEntity;
        public uint EventTick;
        public float Importance;
    }

    /// <summary>
    /// Singleton for managing villager population.
    /// </summary>
    public struct VillagerPopulationData : IComponentData
    {
        public int TotalPopulation;
        public int ActiveWorkers;
        public int IdleVillagers;
        public int CombatCapable;
        public float AverageHealth;
        public float AverageHunger;
        public float AverageMorale;
        public uint LastUpdateTick;
    }

    /// <summary>
    /// Registry summary for the villager domain.
    /// </summary>
    public struct VillagerRegistry : IComponentData
    {
        public int TotalVillagers;
        public int AvailableVillagers;
        public int IdleVillagers;
        public int ReservedVillagers;
        public int CombatReadyVillagers;
        public float AverageHealthPercent;
        public float AverageMoralePercent;
        public float AverageEnergyPercent;
        public uint LastUpdateTick;
        public uint LastSpatialVersion;
        public int SpatialResolvedCount;
        public int SpatialFallbackCount;
        public int SpatialUnmappedCount;
    }

    /// <summary>
    /// Registry entry snapshot describing a villager's current state.
    /// </summary>
    public struct VillagerRegistryEntry : IBufferElementData, IComparable<VillagerRegistryEntry>, IRegistryEntry, IRegistryFlaggedEntry
    {
        public Entity VillagerEntity;
        public int VillagerId;
        public int FactionId;
        public float3 Position;
        public int CellId;
        public uint SpatialVersion;
        public VillagerJob.JobType JobType;
        public VillagerJob.JobPhase JobPhase;
        public uint ActiveTicketId;
        public ushort CurrentResourceTypeIndex;
        public byte AvailabilityFlags;
        public byte Discipline;
        public byte HealthPercent;
        public byte MoralePercent;
        public byte EnergyPercent;
        public byte AIState;
        public byte AIGoal;
        public Entity CurrentTarget;
        public float Productivity;

        public int CompareTo(VillagerRegistryEntry other)
        {
            return VillagerEntity.Index.CompareTo(other.VillagerEntity.Index);
        }

        public Entity RegistryEntity => VillagerEntity;

        public byte RegistryFlags => AvailabilityFlags;
    }

    public static class VillagerAvailabilityFlags
    {
        public const byte Available = 1 << 0;
        public const byte Reserved = 1 << 1;

        public static byte FromAvailability(in VillagerAvailability availability)
        {
            byte flags = 0;
            if (availability.IsAvailable != 0)
            {
                flags |= Available;
            }

            if (availability.IsReserved != 0)
            {
                flags |= Reserved;
            }

            return flags;
        }
    }

    /// <summary>
    /// Optional binding that maps shared AI action indices to villager goals.
    /// </summary>
    public struct VillagerAIUtilityBinding : IComponentData
    {
        public FixedList32Bytes<VillagerAIState.Goal> Goals;
    }

}
